---
title: "Metrics for assessing community assembly processes"
output: html_notebook
bibliography: ../ref.bib  
---

```{r}
source('../env.R')
```

# Introduction
## Are urban columbidae communities strutured by habitat filtering or via competitive interactions?

- With competitive interactions we expect the phylogenetic and functional distance between species to higher than expected than within a random community.
- With habitat filtering we expect the phylogentic and functional distance between species to be lower than expected than within a random community.

@Swenson2007; @CavenderBares2009

## Recommended community metrics 

- Functional diversity of all traits @PetcheyAndGaston2002
- Convex Hull Volume (CHV) of all traits (a multivariate measure of the range of community values) @Cornwall2006
- Mean taxon distance (MTD)  is mean pairwise phylogenetic distances between co-occurring species and is most sensitive to tree-wide patterns of phylogenetic clustering and evenness.
- Mean nearest taxon distance (MNTD) is mean pairwise phylogenetic distances separating each species from its closest co-occurring relative and is most sensitive to phylogenetic clustering or evenness at the tips of phylogeny.
- FD of each trait individually 
- Variance of each trait within community previously used to measure trait clustering
- SDNDr (standard deviation of distances between neighbouring species along a single trait axis, divided by the trait range of the community) is used to detect the regular spacing in species trait values predicted by competitive exclusion.

@Trisos2014

## Recommended null model 
Many metrics sensitive to species richness. Urban communities are governed by the surrounding regional pool. For each urban community, we can generate all of the possible communities with the same species richness as the urban community with species from the regional pool.  The average of all possible communities gives us a null model.
@Miller2017

# Load communities
```{r}
communities = read_csv(filename(COMMUNITY_OUTPUT_DIR, 'communities_for_analysis.csv'))
head(communities)
```

# Cities excluded from analysis
```{r}
community_summary = communities %>% 
  group_by(city_id, city_name) %>% 
  summarise(
    regional_pool_size = n(), 
    urban_pool_high_size = sum(present_urban_high), 
    urban_pool_med_size = sum(present_urban_med), 
    urban_pool_low_size = sum(present_urban_low))
community_summary
```

```{r, echo=F}
report_excluded_communities = function(community_size_param) {
  df = community_summary[,c('city_name', 'regional_pool_size', community_size_param)]
  names(df) = c('city_name', 'regional_pool_size', 'urban_pool_size')
  
  res1 = df$city_name[df$urban_pool_size == 0]
  cat(paste('\n\n**Urban communities with no pigeons:', length(res1), '**\n\n'))
  print(res1)
  
  res2 = df$city_name[df$urban_pool_size == 1 & df$regional_pool_size > 1]
  cat(paste('\n\n**Urban communities single pigeon (but more in regional pool):', length(res2), '**\n\n'))
  print(res2)
  
  res3 = df$city_name[df$urban_pool_size == df$regional_pool_size]
  cat(paste('\n\n**Urban communities with all species in regional pool:', length(res3), '**\n\n'))
  print(res3)
  
  total_excluded = length(unique(append(res1, append(res2, res3))))
  cat(paste('\n\n**Total excluded cities from analysis:', total_excluded, '**\n\n'))
  cat(paste('**Cities remaining in analysis:', nrow(df) - total_excluded, '**\n\n'))
}
```

```{r}
get_valid_cities = function(community_size_param) {
  df = community_summary[,c('city_id', 'city_name', 'regional_pool_size', community_size_param)]
  names(df) = c('city_id', 'city_name', 'regional_pool_size', 'urban_pool_size')
  df[df$urban_pool_size > 1 & df$urban_pool_size < df$regional_pool_size,]
}
```

## Report cities excluded with high threshold
```{r results='asis',echo=FALSE}
report_excluded_communities('urban_pool_high_size')
```

## Report cities excluded with medium threshold
```{r results='asis',echo=FALSE}
report_excluded_communities('urban_pool_med_size')
```

## Report cities excluded with low threshold
```{r results='asis',echo=FALSE}
report_excluded_communities('urban_pool_low_size')
```

# Load trait data
```{r}
avonet_jetz = read_csv(filename(TAXONOMY_OUTPUT_DIR, 'traits_jetz.csv'))
avonet_jetz
```
```{r}
communities$jetz_species_name[!(communities$jetz_species_name %in% avonet_jetz$jetz_species_name)]
```

## Load phylogeny
Phylogenetic maximum clade tree based on a set of trees from @Jetz2012 using the @Hackett2008 backbone.
Trim tree to just species within our urban communities

```{r}
columbidae_tree <- read.tree(filename(TAXONOMY_OUTPUT_DIR, 'phylogeny.tre'))
```

# Create community matrix
```{r}
to_species_matrix = function(valid_city_ids, community_param) {
  c = communities[communities$city_id %in% valid_city_ids, c('city_id', 'jetz_species_name', community_param)]
  names(c) = c('city_id', 'jetz_species_name', 'present')
  m = pivot_wider(c[c$present,c('jetz_species_name', 'present', 'city_id')], names_from = jetz_species_name, values_from = "present", values_fill = list(present = F))
  tibble::column_to_rownames(m, var='city_id')
}
```

## High threshold
```{r}
valid_cities_high = get_valid_cities('urban_pool_high_size')
species_m_high = to_species_matrix(valid_cities_high$city_id, 'present_urban_high')
species_m_high
```

## Medium threshold
```{r}
valid_cities_med = get_valid_cities('urban_pool_med_size')
species_m_med = to_species_matrix(valid_cities_med$city_id, 'present_urban_med')
species_m_med
```

## Low threshold
```{r}
valid_cities_low = get_valid_cities('urban_pool_low_size')
species_m_low = to_species_matrix(valid_cities_low$city_id, 'present_urban_low')
species_m_low
```

## Test communities
```{r}
test_communities = to_species_matrix(c(79, 624, 1786, 2059, 11536), 'present_urban_med')
test_communities
```

# Create functions for generating community metrics

## MNTD
Calculate MNTD for each community using @Kembel2010
```{r}
get_mntd_for_communities = function(communities, phydist_urban_columbidae = cophenetic(columbidae_tree)) {
  urban_community_mntd_result = mntd(as.matrix(communities), phydist_urban_columbidae)
  data.frame(site = rownames(communities), mntd = urban_community_mntd_result)
}

get_mntd_for_communities(test_communities)
```

## FD
Create dentrogram
```{r, fig.height=4}
analysis_all_traits = c('mass', 'locomotory_trait', 'trophic_trait')
analysis_single_traits = c('mass', 'locomotory_trait', 'trophic_trait', 'gape_width')

get_traits_data_frame = function(trait_names) {
  trait_names = prepend('jetz_species_name', trait_names)
  traits = avonet_jetz[,trait_names]
  traits = tibble::column_to_rownames(traits, var='jetz_species_name')
  traits
}

get_dentrogram_for_traits = function(required_traits_for_dentro) {
  traits = get_traits_data_frame(required_traits_for_dentro)
  hclust(dist(traits,method="euclidean"), method="average")
}

dentro = get_dentrogram_for_traits(analysis_all_traits)
plot(dentro)
```

Using @PetcheyAndGaston2002
```{r}
get_fd_for_traits = function(required_traits_for_pd, communities, dentorgram = get_dentrogram_for_traits(required_traits_for_pd)) {
  result = pd(communities, as.phylo(dentorgram))
  data.frame(site = rownames(result), fd = result$PD)
}

get_fd_for_traits(analysis_all_traits, test_communities)
```

```{r}
get_fd_for_traits(c('gape_width'), test_communities)
```

## FRic - Convex Hull of all traits
Using fundiversity package @Grenie2022

```{r}
get_convex_hull = function(trait_names, communities) {
  analysis_trait_values = get_traits_data_frame(trait_names)
  fd_fric(analysis_trait_values, communities)
}

get_convex_hull(analysis_all_traits, test_communities)
```

## Single Trait Variance
```{r}
trait_values = function(trait, community_row) {
  species_names_in_community = names(community_row)[which(community_row == 1, arr.ind=T)[, "col"]]
  traits_for_species_in_community = avonet_jetz[avonet_jetz$jetz_species_name %in% species_names_in_community, ]
  traits_for_species_in_community[[c(trait)]]
}

single_trait_variance = function(trait, communities) {
  variance_of_trait = data.frame()
  for(row in rownames(communities)) {
    community_row = communities[c(row),]
    species_names_in_community = names(community_row)[which(community_row == 1, arr.ind=T)[, "col"]]
    
    result = data.frame(site = row, variance = var(trait_values(trait, community_row)))
    variance_of_trait = rbind(variance_of_trait, result)
  }
  
  variance_of_trait
}

single_trait_variance('mass', test_communities)
single_trait_variance('gape_width', test_communities)
```

## SDNDr
Standard deviation of distances between neighbouring species along a single trait axis, divided by the trait range of the community.

```{r}
SDNDr = function(trait, communities) {
  sdndr_of_trait = data.frame()
  for(row in rownames(communities)) {
    community_row = communities[c(row),]
    
    sorted_trait_values = sort(trait_values(trait, community_row))
    
    sdndr_value = sd(diff(sorted_trait_values)) / (max(sorted_trait_values) - min(sorted_trait_values))
    
    sdndr_of_trait = rbind(sdndr_of_trait, data.frame(site = row, sdndr = sdndr_value))
  }
  
  sdndr_of_trait
}

SDNDr('locomotory_trait', test_communities)
```

## Function to create all metrics
```{r get_community_metrics}
get_community_metrics = function(communities, included_traits_for_multi_trait_metrics = analysis_all_traits, included_traits_for_single_trait_metrics = analysis_single_traits) {

  mntd_result = get_mntd_for_communities(communities)
  fd_all_traits = get_fd_for_traits(included_traits_for_multi_trait_metrics, communities)
  convex_hull = get_convex_hull(included_traits_for_multi_trait_metrics, communities)
  
  result = right_join(mntd_result, right_join(fd_all_traits, convex_hull))
  
  for (trait in included_traits_for_single_trait_metrics) {
    col_name = function(value) {
      paste(trait, value, sep = '_')
    }
  
    fd_single_trait = get_fd_for_traits(trait, communities)
    var_single_trait = single_trait_variance(trait, communities)
    sdndr_single_trait = SDNDr(trait, communities)
    
    single_trait_result = right_join(right_join(fd_single_trait, var_single_trait), sdndr_single_trait)
    names(single_trait_result) = c('site', col_name('fd'), col_name('var'), col_name('sdndr'))
    result = right_join(result, single_trait_result)
  }
  
  result
}
```

```{r}
get_community_metrics(test_communities)
```

# Calculate the null models
Our null model is every possible community of species from the regional pool with the same richness as the urban pool

Find all species in regional pool:
```{r}
test_city_id = 1786 # Manchester
communities$jetz_species_name[communities$city_id == test_city_id]
```

Find urban richness
```{r}
community_summary$urban_pool_med_size[community_summary$city_id == test_city_id]
```

Function to build every possible community
```{r}
create_null_model_communities = function(city_id, urban_richness, regional_species) {
  regional_richness = length(regional_species)
  
  null_model_sites = expand.grid(rep(list(TRUE:FALSE), regional_richness))
  null_model_sites_species_richness =  data.frame(species_richness = pmap_dbl(null_model_sites, sum))
  null_model_sites = cbind(null_model_sites, null_model_sites_species_richness)
  
  null_model_sites = null_model_sites[null_model_sites$species_richness == urban_richness,1:regional_richness]
  colnames(null_model_sites) = regional_species
  null_model_sites
}

create_null_model_communities(
  test_city_id, 
  community_summary$urban_pool_med_size[community_summary$city_id == test_city_id], 
  communities$jetz_species_name[communities$city_id == test_city_id]
)
```

What were the results for the actual urban community in Manchester?
```{r}
get_community_metrics(test_communities[3,])
```

Test creating community metrics for our null model
```{r}
test_null_model_community_metrics = get_community_metrics(
  create_null_model_communities(
    test_city_id, 
    community_summary$urban_pool_med_size[community_summary$city_id == test_city_id], 
    communities$jetz_species_name[communities$city_id == test_city_id]
))
test_null_model_community_metrics
```
# Compare Urban Communities to regional null models
```{r normalise}
normalise = function(actual_value, min_value, max_value) {
  (actual_value - min_value) / (max_value - min_value)
}

normalise(1.5, 1, 2)
```

Create function to test actual value against all possible null model values
```{r}
compare_community_to_null_model = function(metric_name, actual_metric_value, null_model_metric_values) {
  min_value = min(null_model_metric_values)
  max_value = max(null_model_metric_values)
  mean_value = mean(null_model_metric_values)
  sd_value = sd(null_model_metric_values)
  
  result = data.frame(
    normalised = normalise(actual_metric_value, min_value, max_value),
    actual = actual_metric_value,
    min = min_value,
    max = max_value,
    mean = mean_value,
    sd = sd_value
  )
  
  col_name = function(value) {
      paste(metric_name, value, sep = '_')
  }
  
  colnames(result) = c(col_name('normalised'), col_name('actual'), col_name('min'), col_name('max'), col_name('mean'), col_name('sd'))
  result
}
```

```{r}
compare_community_to_null_model('fd', 1215.4, test_null_model_community_metrics$fd)
```
The metrics we want to test:
```{r}
test_community_metrics = get_community_metrics(test_communities)
all_metrics_to_test = colnames(test_community_metrics)[-1]
all_metrics_to_test
```

Compare the actual values to the null model values:
```{r}
create_null_model_test_values = function(city_id, urban_richness, regional_species, actual_values) {
  null_models = create_null_model_communities(city_id, urban_richness, regional_species)
  null_model_community_values = get_community_metrics(null_models)
  
  result = data.frame(city_id = city_id)
  
  for (metric in all_metrics_to_test) {
    result = cbind(result, 
                   compare_community_to_null_model(metric, actual_values[,c(metric)], null_model_community_values[,c(metric)]))
  }
  result
}

create_null_model_test_values(
  test_city_id, 
  community_summary$urban_pool_med_size[community_summary$city_id == test_city_id], 
  communities$jetz_species_name[communities$city_id == test_city_id],
  test_community_metrics[test_community_metrics$site == test_city_id,]
)
```

# Create analysis data
```{r}
create_analysis_data = function(urban_pool_size_param, urban_present_param) {
  result = data.frame()

  valid_cities = get_valid_cities(urban_pool_size_param)
  cm = to_species_matrix(valid_cities$city_id, urban_present_param)

  c = communities[communities$city_id %in% valid_cities$city_id, c('city_id', 'jetz_species_name', urban_present_param)]
  names(c) = c('city_id', 'jetz_species_name', 'present')
  
  cv = get_community_metrics(cm)
    
  cs = community_summary[community_summary$city_id %in% valid_cities$city_id, c('city_id', urban_pool_size_param)]
  names(cs) = c('city_id', 'urban_pool_size')
  
  for (loop_all_city_id in cs$city_id) {
    single_city_result = create_null_model_test_values(
      loop_all_city_id, 
      cs$urban_pool_size[cs$city_id == loop_all_city_id],
      c$jetz_species_name[c$city_id == loop_all_city_id],
      cv[cv$site == loop_all_city_id,]
    )
  
   result = rbind(result, single_city_result)
  }

  right_join(result, cs)
}
```
    

```{r, warning=FALSE, message = FALSE}
high_threshold_result = create_analysis_data('urban_pool_high_size', 'present_urban_high')
high_threshold_result$is_urban_threshold = 'high'
```
    
```{r, warning=FALSE, message = FALSE}
med_threshold_result = create_analysis_data('urban_pool_med_size', 'present_urban_med')
med_threshold_result$is_urban_threshold = 'medium'
```

```{r, warning=FALSE, message = FALSE}
low_threshold_result = create_analysis_data('urban_pool_low_size', 'present_urban_low')
low_threshold_result$is_urban_threshold = 'low'
```

```{r}
write_csv(bind_rows(
  high_threshold_result,
  med_threshold_result,
  low_threshold_result
), filename(COMMUNITY_OUTPUT_DIR, 'community_assembly_metrics.csv'))
```
