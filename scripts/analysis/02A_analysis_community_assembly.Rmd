---
title: "Metrics for assessing community assembly processes"
output: html_notebook
bibliography: ../ref.bib  
---

```{r}
source('../env.R')
```

```{r}
community_data = read_csv(filename(COMMUNITY_OUTPUT_DIR, 'community_assembly_metrics_using_relative_abundance.csv'))
head(community_data)
colnames(community_data)
```

Join on realms
```{r}
city_to_realm = read_csv(filename(CITY_DATA_OUTPUT_DIR, 'realms.csv'))
community_data_with_realm = left_join(community_data, city_to_realm)
```

Cities as points
```{r}
city_points = st_centroid(read_sf(filename(CITY_DATA_OUTPUT_DIR, 'city_selection.shp'))) %>% left_join(community_data_with_realm)
city_points_coords = st_coordinates(city_points)
city_points$latitude = city_points_coords[,1]
city_points$longitude = city_points_coords[,2]
```
  
```{r}
world_map = read_country_boundaries()
```

Load community data, and create long format version
```{r}
communities = read_csv(filename(COMMUNITY_OUTPUT_DIR, 'communities_for_analysis.csv'))
communities
```
```{r}
community_summary = communities %>% group_by(city_id) %>% summarise(regional_pool_size = n(), urban_pool_size = sum(relative_abundance_proxy > 0))
community_summary
```

Load trait data
```{r}
traits = read_csv(filename(TAXONOMY_OUTPUT_DIR, 'traits_jetz.csv'))
head(traits)
```

Load realm geo
```{r}
resolve = read_resolve()
head(resolve)
```

# Summary metrics by Realm
```{r}
test_required_values = function(name, df) {
  cat(paste(
    test_value_wilcox(paste(name, 'MNTD'), df$mntd_normalised),
    test_value_wilcox(paste(name, 'Beak Gape FDiv'), df$gape_width_fdiv_normalised),
    test_value_wilcox(paste(name, 'HWI FDiv'), df$handwing_index_fdiv_normalised),
    test_value_wilcox(paste(name, 'Mass FDiv'), df$mass_fdiv_normalised),
    nrow(df),
    sep = "\n"))
}
```

```{r}
test_required_values('Global', community_data_with_realm)
```

```{r}
unique(community_data_with_realm$core_realm)
```

```{r}
test_required_values('Nearctic', community_data_with_realm[community_data_with_realm$core_realm == 'Nearctic',])
```

```{r}
test_required_values('Neotropic', community_data_with_realm[community_data_with_realm$core_realm == 'Neotropic',])
```

```{r}
test_required_values('Palearctic', community_data_with_realm[community_data_with_realm$core_realm == 'Palearctic',])
```

```{r}
test_required_values('Afrotropic', community_data_with_realm[community_data_with_realm$core_realm == 'Afrotropic',])
```

```{r}
test_required_values('Indomalayan', community_data_with_realm[community_data_with_realm$core_realm == 'Indomalayan',])
```

```{r}
test_required_values('Australasia', community_data_with_realm[community_data_with_realm$core_realm == 'Australasia',])
```

# Summary metrics by introduced species
```{r}
communities = read_csv(filename(COMMUNITY_OUTPUT_DIR, 'communities_for_analysis.csv'))
city_introduced_species = communities %>% group_by(city_id) %>% summarise(number_of_species = n()) %>% left_join(
  communities %>% group_by(city_id) %>% filter(origin == 'Introduced') %>% summarise(number_of_introduced_species = n())
) %>% replace_na(list(number_of_introduced_species = 0))

community_data_with_introductions = left_join(community_data, city_introduced_species)
community_data_with_introductions$has_introduced_species = community_data_with_introductions$number_of_introduced_species > 0
community_data_with_introductions
```

```{r}
community_data_with_introductions[,c('mntd_normalised', 'has_introduced_species')]
```

```{r}
community_data_with_introductions %>% group_by(has_introduced_species) %>% summarise(
  mean_mntd_normalised = mean(mntd_normalised, na.rm = T),
  sd_mntd_normalised = sd(mntd_normalised, na.rm = T),
  
  mean_mass_fdiv_normalised = mean(mass_fdiv_normalised, na.rm = T),
  sd_mass_fdiv_normalised = sd(mass_fdiv_normalised, na.rm = T),
  
  mean_gape_width_fdiv_normalised = mean(gape_width_fdiv_normalised, na.rm = T),
  sd_gape_width_fdiv_normalised = sd(gape_width_fdiv_normalised, na.rm = T),
  
  mean_handwing_index_fdiv_normalised = mean(handwing_index_fdiv_normalised, na.rm = T),
  sd_handwing_index_fdiv_normalised = sd(handwing_index_fdiv_normalised, na.rm = T)
)
```

## MNTD
```{r}
ggplot(community_data_with_introductions, aes(x = has_introduced_species, y = mntd_normalised)) + geom_boxplot()
```

```{r}
wilcox.test(mntd_normalised ~ has_introduced_species, community_data_with_introductions, na.action = 'na.omit')
```

There is a significant difference between the response of cities with introduced species (0.53±0.27) and those without (0.47±0.19) (p-value = 0.02).


## Mass FDiv
```{r}
ggplot(community_data_with_introductions, aes(x = has_introduced_species, y = mass_fdiv_normalised)) + geom_boxplot()
```

```{r}
wilcox.test(mass_fdiv_normalised ~ has_introduced_species, community_data_with_introductions, na.action = 'na.omit')
```
There is a significant difference between the response of cities with introduced species (0.57±0.27) and those without (0.73±0.24) (p < 0.0001)


## Beak Gape FDiv
```{r}
ggplot(community_data_with_introductions, aes(x = has_introduced_species, y = gape_width_fdiv_normalised)) + geom_boxplot()
```

```{r}
wilcox.test(gape_width_fdiv_normalised ~ has_introduced_species, community_data_with_introductions, na.action = 'na.omit')
```
There is NOT a significant difference between the response of cities with introduced species (0.61±0.30) and those without (0.56±0.27)


## HWI FDiv
```{r}
ggplot(community_data_with_introductions, aes(x = has_introduced_species, y = handwing_index_fdiv_normalised)) + geom_boxplot()
```

```{r}
wilcox.test(handwing_index_fdiv_normalised ~ has_introduced_species, community_data_with_introductions, na.action = 'na.omit')
```
There is a significant difference between the response of cities with introduced species (0.49±0.30) and those without (0.79±0.21) (p < 0.0001)


# Examine individual metrics

## Analysis data frame
```{r}
geography = read_csv(filename(CITY_DATA_OUTPUT_DIR, 'geography.csv'))
names(geography)
```

```{r}
analysis_data = community_data_with_realm[,c('city_id', 'mntd_normalised', 'mass_fdiv_normalised', 'gape_width_fdiv_normalised', 'handwing_index_fdiv_normalised', 'core_realm')] %>% 
  left_join(city_points[,c('city_id', 'latitude', 'longitude')]) %>%
  left_join(community_data_with_introductions[,c('city_id', 'has_introduced_species')]) %>%
  left_join(geography)

analysis_data$abs_latitude = abs(analysis_data$latitude)
analysis_data$core_realm = as.factor(analysis_data$core_realm)
analysis_data$has_introduced_species = as.factor(analysis_data$has_introduced_species)
```

```{r}
model_data = function(df, dependant_var) {
  df[,c(dependant_var, 'core_realm', 'abs_latitude', 'latitude', 'longitude', 'has_introduced_species', 'city_avg_ndvi', 'city_avg_elevation', 'city_avg_temp', 'city_avg_min_monthly_temp', 'city_avg_max_monthly_temp', 'city_avg_monthly_temp', 'city_avg_rainfall', 'city_avg_max_monthly_rainfall', 'city_avg_min_monthly_rainfall', 'city_avg_soil_moisture', 'city_max_elev', 'city_min_elev', 'city_elev_range', 'region_20km_avg_ndvi', 'region_20km_avg_elevation', 'region_20km_avg_soil_moisture', 'region_20km_max_elev', 'region_20km_min_elev', 'region_20km_elev_range', 'region_50km_avg_ndvi', 'region_50km_avg_elevation', 'region_50km_avg_soil_moisture', 'region_50km_max_elev', 'region_50km_min_elev', 'region_50km_elev_range')]
}
model_data(analysis_data, 'mntd_normalised')
```

## Helper plot functions
```{r}
geom_normalised_histogram = function(name, gg, legend.position = "right") {
  gg + 
    geom_histogram(aes(fill = core_realm), binwidth = 0.1, position = "dodge") +
    geom_vline(aes(xintercept = 0.5), color = "#000000", size = 0.4) +
    geom_vline(aes(xintercept = 0), color = "#000000", size = 0.2, linetype = "dashed") +
    geom_vline(aes(xintercept = 1), color = "#000000", size = 0.2, linetype = "dashed") + 
    ylab("Number of cities") + xlab("Normalised Response") + ylim(c(0, 70)) +
    labs(title = name, fill = 'Realm') +
    theme_bw() +
    theme(legend.position=legend.position)
}
```

```{r}
geom_map = function(map_sf, title) {
  norm_mntd_analysis_geo = ggplot() + 
    geom_sf(data = world_map, aes(geometry = geometry)) +
    map_sf +
    normalised_colours_scale +
    labs(title = title, colour = 'Normalised\nResponse')
}
```

## Helper Dredge functions
```{r}
# Taken from MuMIN package
# https://rdrr.io/cran/MuMIn/src/R/averaging.R
# https://rdrr.io/cran/MuMIn/src/R/model.avg.R

.coefarr.avg <-
  function(cfarr, weight, revised.var, full, alpha) {	
    weight <- weight / sum(weight)
    nCoef <- dim(cfarr)[3L]
    if(full) {
      nas <- is.na(cfarr[, 1L, ]) & is.na(cfarr[, 2L, ])
      cfarr[, 1L, ][nas] <- cfarr[, 2L, ][nas] <- 0
      #cfarr[, 1L:2L, ][is.na(cfarr[, 1L:2L, ])] <- 0
      if(!all(is.na(cfarr[, 3L, ])))
        cfarr[ ,3L, ][is.na(cfarr[ , 3L, ])] <- Inf
    }
    
    avgcoef <- array(dim = c(nCoef, 5L),
                     dimnames = list(dimnames(cfarr)[[3L]], c("Estimate",
                                                              "Std. Error", "Adjusted SE", "Lower CI", "Upper CI")))
    for(i in seq_len(nCoef))
      avgcoef[i, ] <- par.avg(cfarr[, 1L, i], cfarr[, 2L, i], weight,
                              df = cfarr[, 3L, i], alpha = alpha, revised.var = revised.var)
    
    avgcoef[is.nan(avgcoef)] <- NA
    return(avgcoef)
  }

.makecoefmat <- function(cf) {
  no.ase <- all(is.na(cf[, 3L]))
  z <- abs(cf[, 1L] / cf[, if(no.ase) 2L else 3L])
  pval <- 2 * pnorm(z, lower.tail = FALSE)
  cbind(cf[, if(no.ase) 1L:2L else 1L:3L, drop = FALSE],
        `z value` = z, `Pr(>|z|)` = zapsmall(pval))
}

# Generate model selections using lmer, dredge, and model.avg
# `forumla` : a two-sided linear formula object describing both the fixed-effects and random-effects part of the model
# `data` : the data frame containing the variables from the formula
# `aic_delta` : the AIC delta to use for selecting models in model average
model_average <- function(formula, data, aic_delta) {
  model <- lm(
    formula,
    data=data
  )
  dredge_result <- dredge(model)
  summary(model.avg(dredge_result, subset = delta < aic_delta))
}

# Create a summary data frame containing the selected variables from a model
# `model_sum` : The model summary output from `model_average`
model_summary <- function(response_var, model_sum) {
  .column_name <- function(postfix) {
    postfix
  }
  
  # just return the estimate and p value
  weight <- model_sum$msTable[, 5L]
  
  coefmat.full <- as.data.frame(.makecoefmat(.coefarr.avg(model_sum$coefArray, weight,
                                                          attr(model_sum, "revised.var"), TRUE, 0.05)))
  
  coefmat.subset <-
    as.data.frame(.makecoefmat(.coefarr.avg(model_sum$coefArray, weight,
                                            attr(model_sum, "revised.var"), FALSE, 0.05)))
  
  
  coefmat.subset <- coefmat.subset[-c(1), c(1, 2, 5)]
  names(coefmat.subset) <- c(.column_name("estimate"), .column_name("error"), .column_name("p"))
  coefmat.subset <- tibble::rownames_to_column(coefmat.subset, "explanatory")
  coefmat.subset$model = 'subset'
  
  coefmat.full <- coefmat.full[-c(1), c(1, 2, 5)]
  names(coefmat.full) <- c(.column_name("estimate"), .column_name("error"), .column_name("p"))
  coefmat.full <- tibble::rownames_to_column(coefmat.full, "explanatory")
  coefmat.full$model = 'full'
  
  rbind(coefmat.full, coefmat.subset)
}
```

## MNTD
```{r}
norm_mntd_analysis_plot = geom_normalised_histogram(
  'MNTD', 
  ggplot(analysis_data, aes(mntd_normalised))
)
norm_mntd_analysis_plot
```

```{r}
norm_mntd_analysis_geo = geom_map(geom_sf(data = analysis_data, aes(color = mntd_normalised, geometry = geometry)), 'MNTD')
norm_mntd_analysis_geo
ggsave(filename(FIGURES_OUTPUT_DIR, 'normalised_mntd_using_abundance.jpg'), width = 2500, height=1100, units = 'px')
```

```{r}
norm_mntd_analysis_data = model_data(analysis_data[!is.na(analysis_data$mntd_normalised),], 'mntd_normalised')
norm_mntd_analysis_result <- model_average(mntd_normalised ~ ., norm_mntd_analysis_data, 4)
model_summary(norm_mntd_analysis_result)
```

## Gape width - FDiv
```{r}
norm_gape_fdiv_analysis_plot = geom_normalised_histogram(
  'Gape FDiv', 
  ggplot(analysis_data, aes(gape_width_fdiv_normalised))
)
norm_gape_fdiv_analysis_plot
```

```{r}
norm_gape_fdiv_analysis_geo = geom_map(geom_sf(data = analysis_data, aes(color = gape_width_fdiv_normalised, geometry = geometry)), 'Gape Width FDiv')
norm_gape_fdiv_analysis_geo
ggsave(filename(FIGURES_OUTPUT_DIR, 'normalised_gape_width_using_abundance.jpg'), width = 2500, height=1100, units = 'px')
```

```{r}
norm_gape_fdiv_analysis_data = model_data(analysis_data[!is.na(analysis_data$gape_width_fdiv_normalised),], 'gape_width_fdiv_normalised')
norm_gape_fdiv_analysis_result <- model_average(gape_width_fdiv_normalised ~ ., norm_gape_fdiv_analysis_data, 4)
model_summary(norm_gape_fdiv_analysis_result)
```

## HWI - FDiv
```{r}
norm_hwi_fdiv_loco_analysis_plot = geom_normalised_histogram(
  'HWI FDiv', 
  ggplot(analysis_data, aes(handwing_index_fdiv_normalised))
)
norm_hwi_fdiv_loco_analysis_plot
```

```{r}
norm_hwi_fdiv_analysis_geo = geom_map(geom_sf(data = analysis_data, aes(color = handwing_index_fdiv_normalised, geometry = geometry)), 'HWI FDiv')
norm_hwi_fdiv_analysis_geo
ggsave(filename(FIGURES_OUTPUT_DIR, 'normalised_hwi_using_abundance.jpg'), width = 2500, height=1100, units = 'px')
```

```{r}
norm_hwi_fdiv_analysis_data = model_data(analysis_data[!is.na(analysis_data$handwing_index_fdiv_normalised),], 'handwing_index_fdiv_normalised')
norm_hwi_fdiv_analysis_result <- model_average(handwing_index_fdiv_normalised ~ ., norm_hwi_fdiv_analysis_data, 4)
model_summary(norm_hwi_fdiv_analysis_result)
```

## Mass - FDiv
```{r}
norm_mass_fdiv_loco_analysis_plot = geom_normalised_histogram(
  'Mass FDiv', 
  ggplot(analysis_data, aes(mass_fdiv_normalised))
)
norm_mass_fdiv_loco_analysis_plot
```

```{r}
norm_mass_fdiv_analysis_geo = geom_map(geom_sf(data = analysis_data, aes(color = mass_fdiv_normalised, geometry = geometry)), 'Mass FDiv')
norm_mass_fdiv_analysis_geo
ggsave(filename(FIGURES_OUTPUT_DIR, 'normalised_mass_using_abundance.jpg'), width = 2500, height=1100, units = 'px')
```

```{r}
norm_mass_fdiv_analysis_data = model_data(analysis_data[!is.na(analysis_data$mass_fdiv_normalised),], 'mass_fdiv_normalised')
norm_mass_fdiv_analysis_result <- model_average(mass_fdiv_normalised ~ ., norm_mass_fdiv_analysis_data, 4)
model_summary(norm_mass_fdiv_analysis_result)
```

# Compare metrics against each other
```{r}
ggplot(analysis_data, aes(x = gape_width_fdiv_normalised, y = mntd_normalised, colour = core_realm)) + 
  geom_point() +
  ylab("MNTD") + 
  xlab("Gape Width FDiv") +
  theme_bw() + labs(color = "Realm")
```

```{r}
ggplot(analysis_data, aes(x = handwing_index_fdiv_normalised, y = mntd_normalised, colour = core_realm)) + 
  geom_point() +
  ylab("MNTD") + 
  xlab("HWI FDiv") +
  theme_bw() + labs(color = "Realm")
```

```{r}
ggplot(analysis_data, aes(x = handwing_index_fdiv_normalised, y = gape_width_fdiv_normalised, colour = core_realm)) + 
  geom_point() +
  ylab("Gape Width FDiv") + 
  xlab("HWI FDiv") +
  theme_bw() + labs(color = "Realm")
```

```{r}
mntd_fdiv_analysis = analysis_data %>% 
  dplyr::select(city_id,  mntd_normalised, handwing_index_fdiv_normalised, gape_width_fdiv_normalised) %>%
  left_join(community_summary) %>%
  mutate(urban_pool_perc = urban_pool_size * 100 / regional_pool_size)
mntd_fdiv_analysis
```

```{r}
ggpairs(mntd_fdiv_analysis %>% dplyr::select(mntd_normalised, handwing_index_fdiv_normalised, gape_width_fdiv_normalised, regional_pool_size, urban_pool_size, urban_pool_perc))
ggsave(filename(FIGURES_OUTPUT_DIR, 'appendix_normalised_correlation.jpg'))
```


