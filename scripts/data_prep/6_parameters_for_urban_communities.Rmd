---
title: "Find parameters for building urban communities"
output: html_notebook
bibliography: ../ref.bib 
---

```{r}
source('../env.R')
```

```{r}
taxonmomic_mapping = read_csv(filename(TAXONOMY_OUTPUT_DIR, 'taxonomy_mapping.csv'))
```

Find sample size, and percentage of checklists (or percentage of effort) for valid urban communities based on presence test data.

# Load abundance data
```{r}
abundance_data = read_csv(filename(EBIRD_WORKING_OUTPUT_DIR, 'ebird_trends_abundance_test_data.csv'))
```

```{r}
species_available = unique(abundance_data$species)
```

# Create regional pool data
```{r}
inspection_cities = c('Manchester', 'Bogota', 'Los Angeles', 'Jakarta', 'Nairobi')
```

```{r}
regional_pool_data_input = read_csv(filename(BIRDLIFE_WORKING_OUTPUT_DIR, 'urban_distributions.csv'))
regional_pool_data_input$seasonal = factor(regional_pool_data_input$seasonal, levels = c('Resident', 'Breeding Season', 'Non-breeding Season', 'Passage', ordered = T))
regional_pool_data_input[regional_pool_data_input$city_name %in% inspection_cities,] 
```

```{r}
regional_pool_data = regional_pool_data_input %>% 
  filter(species_name %in% species_available) %>%
  arrange(seasonal) %>%
  group_by(city_id, city_name, species_name) %>%
  summarise(seasonal = first(seasonal)) %>%
  arrange(city_id, species_name)
```

```{r}
regional_pool_data[regional_pool_data$city_name %in% inspection_cities,]
```

# Filter abundance data to regional pools
```{r}
abundance_data_regional = left_join(regional_pool_data, abundance_data, by = c('city_id' = 'city_id', 'city_name' = 'city_name', 'species_name' = 'species'))
abundance_data_regional = abundance_data_regional %>% arrange(city_id) %>% select(city_id, city_name, species_name, seasonal, breeding, nonbreeding, resident)
```

```{r}
abundance_data_regional[abundance_data_regional$city_name %in% inspection_cities,]
```

Are any species now missing that are abundant?
```{r}
city_id_species_pairs_present = paste(abundance_data_regional$species_name, abundance_data_regional$city_id, sep = '::')
abundance_data %>% 
  filter(breeding > 0 | nonbreeding > 0 | resident > 0) %>% 
  group_by(city_id, species) %>% 
  filter(!(paste(species, city_id, sep = '::') %in% city_id_species_pairs_present)) %>%
  select(city_id, city_name, species, breeding, nonbreeding, resident)
```

# Create urban summary data
Get number of checklists and total effort in each city
```{r}
urban_checklists = read_csv(filename(EBIRD_WORKING_OUTPUT_DIR, 'urban_checklists.csv'))

urban_summary = urban_checklists %>% group_by(city_id, city_name) %>% summarise(total_city_checklists = n(), total_city_effort = sum(duration))

urban_summary[urban_summary$city_name %in% inspection_cities,]
```

# Create urban pools
For each of our test species, find the number of checklists and total effort in each city
```{r}
ebird_raw = read_csv(filename(EBIRD_WORKING_OUTPUT_DIR, 'urban_columbidae.csv'))
head(ebird_raw)
```

Join eBird data to taxonomy, and then ensure species only appear on each checklists. e.g. deduplicate any species that had duplicates created by taxonomy mapping.
```{r}
urban_columbidae_raw_ebird_records = 
  left_join(ebird_raw, taxonmomic_mapping, by = c('species_name' = 'ebird_species_name')) %>%
  filter(species_name.y %in% species_available) %>%
  group_by(checklist_id, city_id, city_name, species_name.y) %>%
  summarise(
    duration = max(duration)
  ) %>%
  rename(species_name = species_name.y) %>%
  arrange(city_name)

urban_columbidae_raw_ebird_records[urban_columbidae_raw_ebird_records$city_name %in% inspection_cities, ]
```

Now calculate the total number of checklists each species appears on, and then total effort of those checklists.
This gives a single row for each species in each city.
Then join the data onto the regional pool data, and the urban summary data.
```{r}
urban_ebird_columbidae_city_summary = urban_columbidae_raw_ebird_records %>% 
  group_by(city_id, city_name, species_name) %>% 
  summarise(total_presence_checklists = n(), total_presence_effort = sum(duration)) %>%
  left_join(regional_pool_data, by = c('city_id' = 'city_id', 'city_name' = 'city_name', 'species_name' = 'species_name')) %>%
  left_join(urban_summary, by = c('city_id' = 'city_id', 'city_name' = 'city_name')) %>%
  arrange(city_id, species_name)
```

NA for seasonal indicates that the species is on an eBird checklist for the city, but not in the birdlife regional pool.
```{r}
urban_ebird_columbidae_city_summary[urban_ebird_columbidae_city_summary$city_name %in% inspection_cities,]
```

We also want records for each city that could have that pigeon (e.g. in regional pool range) but has no eBird records.
Create absence records for all species in the birdlife regional pool data for all cities.
```{r}
urban_columbidae_absence_records_part1 = left_join(regional_pool_data, urban_summary)

urban_columbidae_absence_records_part1$total_presence_checklists = 0
urban_columbidae_absence_records_part1$total_presence_effort = 0

urban_columbidae_absence_records = urban_columbidae_absence_records_part1[!is.na(urban_columbidae_absence_records_part1$total_city_checklists),]

urban_columbidae_absence_records[urban_columbidae_absence_records$city_name %in% inspection_cities,]
```

Append the absence and presence data together, and then deduplicate to ensure only one species per city.
Then calculate the percentage of all checklists, and the percentage of total effort in a city for each species.
```{r}
urban_columbidae_presence_and_absence = rbind(urban_ebird_columbidae_city_summary, urban_columbidae_absence_records) %>%
  group_by(city_id, city_name, species_name, total_city_checklists, total_city_effort, seasonal) %>%
  summarise(total_presence_checklists = max(total_presence_checklists), total_presence_effort = max(total_presence_effort)) %>%
  arrange(city_id, species_name)

urban_columbidae_presence_and_absence$percentage_checklists = urban_columbidae_presence_and_absence$total_presence_checklists * 100 / urban_columbidae_presence_and_absence$total_city_checklists
urban_columbidae_presence_and_absence$percentage_effort = urban_columbidae_presence_and_absence$total_presence_effort * 100 / urban_columbidae_presence_and_absence$total_city_effort

urban_columbidae_presence_and_absence[urban_columbidae_presence_and_absence$city_name %in% inspection_cities,]
```

# Join all data together
Finally join our our test data result to show predicted abundance, remove any NA abundance as there is insufficent data in these places for a prediction.
```{r}
columbidae = left_join(urban_columbidae_presence_and_absence, abundance_data, by = c('species_name' = 'species', 'city_id' = 'city_id', 'city_name' = 'city_name'))
columbidae[columbidae$city_name %in% inspection_cities,]
```

# Plot our species pools for each inspection city
```{r}
plot_city_species = function(city_id) {
  city_name = urban_summary$city_name[urban_summary$city_id == city_id]
  total_checklists = urban_summary$total_city_checklists[urban_checklists$city_id == city_id]
  
  ggplot(columbidae[columbidae$city_id == city_id,], aes(x = species_name, y = percentage_checklists, fill = seasonal)) + 
    geom_bar(stat = "identity") + 
    geom_text(aes(label = paste('breeding', round(breeding, 1), '\nresident', round(resident, 1)))) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
    xlab('Species name') + ylab('% of Checklist present') + 
    facet_wrap(~city_id) + 
    geom_hline(yintercept=5, linetype='dotted', col = 'red') +
    labs(title = paste(city_name, total_checklists))
}
```

```{r}
plot_city_species(14)
```

```{r}
plot_city_species(624)
```

```{r}
plot_city_species(1786)
```

```{r}
plot_city_species(4830)
```

```{r}
plot_city_species(11920)
```


# Attempt to predict abundance from percentage of checklists present
```{r}
ggplot(columbidae[columbidae$species_name == 'Columba palumbus',], aes(y = percentage_checklists, x = breeding, color = log(total_city_checklists))) + geom_jitter() + geom_jitter() + scale_colour_gradient2(
  low = "red",
  mid = "yellow",
  high = "darkgreen",
  midpoint = log(100),
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour",
)
```
```{r}
ggplot(columbidae, aes(y = percentage_checklists, x = sqrt(breeding), color = log(total_city_checklists))) + geom_jitter() + geom_jitter() + scale_colour_gradient2(
  low = "red",
  mid = "yellow",
  high = "darkgreen",
  midpoint = log(100),
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour",
) + geom_smooth()
```
Outliers
```{r}
columbidae[!is.na(columbidae$breeding) & sqrt(columbidae$breeding) > 3.5,]
```

```{r}
ggplot(columbidae, aes(y = percentage_checklists, x = sqrt(resident), color = log(total_city_checklists))) + geom_jitter() + geom_jitter() + scale_colour_gradient2(
  low = "red",
  mid = "yellow",
  high = "darkgreen",
  midpoint = log(100),
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour",
) + geom_smooth()
```
Outliers
```{r}
columbidae[!is.na(columbidae$resident) & sqrt(columbidae$resident) > 5,]
```

Try mapping max abundance
```{r}
columbidae$max_abundance = apply(columbidae[,c('breeding', 'nonbreeding', 'resident')], 1, max, na.rm = T)
columbidae$max_abundance[columbidae$max_abundance == -Inf] = NA
```

```{r}
ggplot(columbidae[!is.na(columbidae$max_abundance) & sqrt(columbidae$max_abundance) < 5,], aes(y = percentage_checklists, x = sqrt(max_abundance), color = log(total_city_checklists))) + geom_jitter() + geom_jitter() + scale_colour_gradient2(
  low = "red",
  mid = "yellow",
  high = "darkgreen",
  midpoint = log(100),
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour",
) + geom_smooth()
```
```{r}
linear_model = lm(percentage_checklists ~ sqrt(max_abundance), columbidae[!is.na(columbidae$max_abundance) & sqrt(columbidae$max_abundance) < 5,])
summary(linear_model)
plot(linear_model)
```

```{r}
linear_model = lm(percentage_checklists ~ max_abundance, columbidae[!is.na(columbidae$max_abundance) & sqrt(columbidae$max_abundance) < 5,])
summary(linear_model)
plot(linear_model)
```
```{r}
trimmed_data = columbidae[!is.na(columbidae$max_abundance) & sqrt(columbidae$max_abundance) < 5,]
seeds = c(123, 456, 678, 10, 11, 345, 32, 11, 54, 90, 9999, 1234, 5678, 2323, 9011, 532, 111, 678, 6501, 3)

# min_city_checklists is the minimum number of cities a checklist must have to be included.
# get_model is a function that takes a dataframe subset of `columbidae`, and returns the result of `lm`
# get_actual is a function that returns the expected result of the prediction given a dataframe subset of `columbidae`
get_mean_test_error = function(min_city_checklists, get_model, get_expected) {
  data = trimmed_data[trimmed_data$total_city_checklists >= min_city_checklists,]
  
  result = data.frame()
  
  for(seed in seeds) {
    set.seed(seed)
    train = sample(1:nrow(data), nrow(data)/2)
    test=(-train)
    
    model = get_model(data[train,])
    prediction = predict(model, data[test,])
    
    result = rbind(result, data.frame(prediction = prediction, actual = data$max_abundance[test]))
  }

  sum((result$prediction - result$actual)^2) / nrow(result)
}

min_city_checklists = seq(0, 5000, by=10)
```

First test predicting abundance directly.
```{r}
result = data.frame()

for (min_city_checklist in min_city_checklists) {
  result = rbind(result, data.frame(
    min_city_checklist = min_city_checklist,
    mean_test_error = get_mean_test_error(
      min_city_checklist, 
      function(training_data) {lm(max_abundance ~ percentage_checklists, training_data)},
      function(test_data) {test_data$max_abundance})
  ))
}

ggplot(result, aes(x = min_city_checklist, y = mean_test_error)) + geom_line()
```

Second test predicting the sqrt of abundance.
```{r}
result = data.frame()

for (min_city_checklist in min_city_checklists) {
  result = rbind(result, data.frame(
    min_city_checklist = min_city_checklist,
    mean_test_error = get_mean_test_error(
      min_city_checklist, 
      function(training_data) {lm(sqrt(max_abundance) ~ percentage_checklists, training_data)},
      function(test_data) {sqrt(test_data$max_abundance)})
  ))
}

ggplot(result, aes(x = min_city_checklist, y = mean_test_error)) + geom_line()
```

Third test predicting the presence.
```{r}
trimmed_data$nonzero_abundance = trimmed_data$max_abundance > 0
```

```{r}
trimmed_data$total_city_checklists_bin = cut(trimmed_data$total_city_checklists, breaks = 25, labels = F)
trimmed_data$total_city_checklists_bin = as.factor(trimmed_data$total_city_checklists_bin)
ggplot(trimmed_data, aes(x = total_city_checklists_bin, y = percentage_checklists)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + facet_wrap(~ nonzero_abundance)
```

```{r}
get_true_false_test_results = function(min_city_checklists) {
  data = trimmed_data[trimmed_data$total_city_checklists >= min_city_checklists,]
  
  result = data.frame()
  coeeffs = c()
  
  for(seed in seeds) {
    train = sample(1:nrow(data), nrow(data) / 2)
    test=(-train)
    
    model = glm(nonzero_abundance ~ percentage_checklists, "binomial", data[train,])
    prediction = predict(model, data[test,], type = "response")
    
    result = rbind(result, data.frame(actual = data$nonzero_abundance[test], predicted = prediction))
    coeeffs = append(coeeffs, model$coefficients['percentage_checklists'])
  }

  data.frame(
    mean_false_probability = mean(result$predicted[!result$actual]),
    mean_true_probablility = mean(result$predicted[result$actual]),
    percentage_checklists_cutoff = mean(coeeffs),
    min_city_checklists = min_city_checklists
  )
}
```


```{r}
result = data.frame()

for (min_city_checklist in min_city_checklists) {
  result = rbind(result, get_true_false_test_results(min_city_checklist))
}

ggplot(result, aes(x = min_city_checklists, y = mean_false_probability)) + geom_line()
```


```{r}
result[result$min_city_checklists %in% c(500, 1000, 1500, 2000),]
```
